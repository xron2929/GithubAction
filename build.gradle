plugins {
    id 'java'
    id 'org.springframework.boot' version '2.7.7'
    id 'io.spring.dependency-management' version '1.1.0'
}

group = 'dev.be'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'io.micrometer:micrometer-registry-prometheus'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation 'mysql:mysql-connector-java'
    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
    useJUnitPlatform()
}
// 개발자님은 이걸로 jar 파일 2개 ls로 실행하고 쉘 명령어 중에 먼저 실행 기준으로 처리하는게 포함되어있는 걸 사용해서
// 그것 떄문에 스프링이 작동이 안하니까, gradle로 추가하셨는데 대체 방법은 ls *.jar 대신에 jar 파일을 정확히 명시하는 것도 방법일 꺼고
// 깃허브에서 build.gradle 대신 도커 파일에서 스프링부트를 불러와서 파일 이름을 설정하고 그걸 깃허브 액션이 jar를 실행하도록 하는 것도 방법이고...
// 저기서 중복되는 로직이 있어서 코드도 리팩토링을 해야될듯 나아가 kakao tech 자료처럼 중복되는 쉘을 불러와서 서버도 대규모가 되면의미가 있을 것 같은데
// 난이도가 높아서..  일단 그대로 따라해보고 나중에 천천히 리팩토링 예정
// 그리고 깃허브의 secrets를 예쁘게 활용해서 내 입맛에 맞게 커스텀도 해봐야할듯..
// 일단 private으로 하고 싶긴한데
// 쓰기가 앵간히 까다롭긴 해서 public으로 배포하고 private으로 감춰서 개발해야할듯
// 포트폴리오로 완성된거 아니라 미완성인거 여러개 만들면 좋게보이진 않을 것 같기도 해서..


jar {
    enabled=false
}
